// infra/lib/tiltfile.ts

import type {
  ManifestDefinition,
  AppDefinition,
  SetupScriptDefinition,
  LocalAppDefinition,
} from './types'
import * as path from 'path'

export function generateTiltfile(
  definitions: ManifestDefinition[],
  appDirs: Map<string, string>,
  projectRoot: string
): string {
  const lines: string[] = [
    '# Generated by @nebula/infra - do not edit manually',
    '# Run `just synth` to regenerate',
    '',
    "allow_k8s_contexts('k3d-nebula')",
    '',
    "default_registry('nebula-registry:5000')",
    '',
  ]

  for (const def of definitions) {
    const appDir = appDirs.get(def.name)
    if (!appDir) continue

    switch (def.type) {
      case 'app':
        lines.push(...generateAppTilt(def, appDir))
        break
      case 'setupScript':
        lines.push(...generateSetupScriptTilt(def, projectRoot))
        break
      case 'localApp':
        lines.push(...generateLocalAppTilt(def, appDir))
        break
    }
    lines.push('')
  }

  return lines.join('\n')
}

function generateAppTilt(def: AppDefinition, appDir: string): string[] {
  const { name, config } = def
  const lines: string[] = []

  // Docker build for dockerfile apps
  if ('dockerfile' in config && config.dockerfile) {
    const dockerfilePath = path.join(appDir, 'deploy', config.dockerfile)
    const contextPath = path.dirname(path.dirname(appDir)) // project root

    let dockerBuild = `docker_build(\n  '${name}',\n  '${contextPath}',\n  dockerfile='${dockerfilePath}'`

    if (config.buildTarget) {
      dockerBuild += `,\n  target='${config.buildTarget}'`
    }

    if (config.liveUpdate && config.liveUpdate.length > 0) {
      const syncs = config.liveUpdate
        .map((p) => {
          const fullPath = path.resolve(appDir, p)
          // Convert relative path to absolute container path
          // Container workdir is /app/apps/<name>, so resolve relative to that
          const containerPath = p.startsWith('../../')
            ? '/app/' + p.replace('../../', '')
            : '/app/apps/' + name.replace('nebula-', '') + '/' + p.replace('./', '')
          return `    sync('${fullPath}', '${containerPath}')`
        })
        .join(',\n')
      dockerBuild += `,\n  live_update=[\n${syncs}\n  ]`
    }

    dockerBuild += '\n)'
    lines.push(dockerBuild)
  }

  // K8s YAML (path relative to dist/ where this Tiltfile lives)
  lines.push(`k8s_yaml('${name}.k8s.yaml')`)

  // Extra K8s YAML files (e.g., RBAC)
  if ('extraYaml' in config && config.extraYaml) {
    for (const yamlFile of config.extraYaml) {
      const yamlPath = path.join(appDir, 'deploy', yamlFile)
      lines.push(`k8s_yaml('${yamlPath}')`)
    }
  }

  // K8s resource config
  const resourceParts: string[] = [`  '${name}'`]

  if (config.portForwards && config.portForwards.length > 0) {
    const forwards = config.portForwards.map((p) => `'${p}'`).join(', ')
    resourceParts.push(`  port_forwards=[${forwards}]`)
  }

  if (config.resourceDeps && config.resourceDeps.length > 0) {
    const deps = config.resourceDeps.map((d) => `'${d}'`).join(', ')
    resourceParts.push(`  resource_deps=[${deps}]`)
  }

  if (config.labels && config.labels.length > 0) {
    const lbls = config.labels.map((l) => `'${l}'`).join(', ')
    resourceParts.push(`  labels=[${lbls}]`)
  }

  lines.push(`k8s_resource(\n${resourceParts.join(',\n')}\n)`)

  return lines
}

function generateSetupScriptTilt(def: SetupScriptDefinition, projectRoot: string): string[] {
  const { name, config } = def
  const parts: string[] = [`  '${name}'`]

  // Escape single quotes and wrap in triple-quoted string for Starlark
  const escapedCmd = config.cmd.replace(/'/g, "\\'")
  parts.push(`  cmd='''${escapedCmd}'''`)

  // Use cwd if specified, otherwise project root
  const dir = config.cwd ? path.resolve(projectRoot, config.cwd) : projectRoot
  parts.push(`  dir='${dir}'`)

  if (config.resourceDeps && config.resourceDeps.length > 0) {
    const deps = config.resourceDeps.map((d) => `'${d}'`).join(', ')
    parts.push(`  resource_deps=[${deps}]`)
  }

  if (config.labels && config.labels.length > 0) {
    const lbls = config.labels.map((l) => `'${l}'`).join(', ')
    parts.push(`  labels=[${lbls}]`)
  }

  parts.push('  allow_parallel=True')

  return [`local_resource(\n${parts.join(',\n')}\n)`]
}

function generateLocalAppTilt(def: LocalAppDefinition, appDir: string): string[] {
  const { name, config } = def
  const parts: string[] = [`  '${name}'`]

  parts.push(`  serve_cmd='${config.cmd}'`)
  parts.push(`  serve_dir='${appDir}'`)

  if (config.resourceDeps && config.resourceDeps.length > 0) {
    const deps = config.resourceDeps.map((d) => `'${d}'`).join(', ')
    parts.push(`  resource_deps=[${deps}]`)
  }

  if (config.labels && config.labels.length > 0) {
    const lbls = config.labels.map((l) => `'${l}'`).join(', ')
    parts.push(`  labels=[${lbls}]`)
  }

  return [`local_resource(\n${parts.join(',\n')}\n)`]
}
